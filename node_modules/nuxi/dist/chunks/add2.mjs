import * as fs from 'node:fs';
import { homedir } from 'node:os';
import { dirname, extname, join as join$1 } from 'node:path';
import process from 'node:process';
import { a as resolvePath, r as readPackageJSON } from '../shared/nuxi.CQKunj3-.mjs';
import { S as SUPPORTED_EXTENSIONS } from '../shared/nuxi.C5KDh4qT.mjs';
import { mkdir, writeFile, readFile } from 'node:fs/promises';
import 'node:module';
import '../shared/nuxi.oF0sJJb9.mjs';
import { j as join } from '../shared/nuxi.BZI8rqcO.mjs';
import { d as defineCommand, l as logger, r as runCommand, b as colors } from '../shared/nuxi.vClchuwn.mjs';
import 'node:tty';
import { a as addDependency } from '../shared/nuxi.BbDL64qi.mjs';
import { f as fetchModules, g as getNuxtVersion, c as checkNuxtCompatibility, s as semverExports, $ as $fetch } from '../shared/nuxi.BrE13ZGm.mjs';
import { j as joinURL } from '../shared/nuxi.ChFrgAY-.mjs';
import { c as cwdArgs, l as logLevelArgs } from '../shared/nuxi.DpekDEZq.mjs';
import { r as resolve } from '../shared/nuxi.BHLUJ6h2.mjs';
import 'node:url';
import 'node:assert';
import 'node:v8';
import 'node:util';
import 'fs';
import 'path';
import 'os';
import 'crypto';
import '../shared/nuxi.E-ZsRS8r.mjs';
import 'node:crypto';
import 'node:perf_hooks';
import 'node:vm';
import 'assert';
import 'module';
import 'process';
import 'tty';
import 'url';
import 'util';
import 'v8';
import 'node:http';
import 'node:https';
import 'node:zlib';
import 'node:stream';
import 'node:buffer';
import 'node:net';
import '../shared/nuxi.BPuj-7ta.mjs';

const UPDATABLE_EXTS = [".js", ".ts", ".mjs", ".cjs", ".mts", ".cts"];
async function updateConfig(opts) {
  const { parseModule } = await import('./index8.mjs');
  let configFile = await _tryResolve(
    `./${opts.configFile}`,
    opts.cwd,
    SUPPORTED_EXTENSIONS
  ) || await _tryResolve(
    `./.config/${opts.configFile}`,
    opts.cwd,
    SUPPORTED_EXTENSIONS
  ) || await _tryResolve(
    `./.config/${opts.configFile.split(".")[0]}`,
    opts.cwd,
    SUPPORTED_EXTENSIONS
  );
  let created = false;
  if (!configFile) {
    configFile = join(
      opts.cwd,
      opts.configFile + (opts.createExtension || ".ts")
    );
    const createResult = await opts.onCreate?.({ configFile }) ?? true;
    if (!createResult) {
      throw new Error("Config file creation aborted.");
    }
    const content = typeof createResult === "string" ? createResult : `export default {}
`;
    await mkdir(dirname(configFile), { recursive: true });
    await writeFile(configFile, content, "utf8");
    created = true;
  }
  const ext = extname(configFile);
  if (!UPDATABLE_EXTS.includes(ext)) {
    throw new Error(
      `Unsupported config file extension: ${ext} (${configFile}) (supported: ${UPDATABLE_EXTS.join(", ")})`
    );
  }
  const contents = await readFile(configFile, "utf8");
  const _module = parseModule(contents, opts.magicast);
  const defaultExport = _module.exports.default;
  if (!defaultExport) {
    throw new Error("Default export is missing in the config file!");
  }
  const configObj = defaultExport.$type === "function-call" ? defaultExport.$args[0] : defaultExport;
  await opts.onUpdate?.(configObj);
  await writeFile(configFile, _module.generate().code);
  return {
    configFile,
    created
  };
}
function _tryResolve(path, cwd, exts) {
  return resolvePath(path, {
    url: join(cwd, "_index.js"),
    extensions: exts
  }).catch(() => undefined);
}

const add = defineCommand({
  meta: {
    name: "add",
    description: "Add Nuxt modules"
  },
  args: {
    ...cwdArgs,
    ...logLevelArgs,
    moduleName: {
      type: "positional",
      description: "Specify one or more modules to install by name, separated by spaces"
    },
    skipInstall: {
      type: "boolean",
      description: "Skip npm install"
    },
    skipConfig: {
      type: "boolean",
      description: "Skip nuxt.config.ts update"
    },
    dev: {
      type: "boolean",
      description: "Install modules as dev dependencies"
    }
  },
  async setup(ctx) {
    const cwd = resolve(ctx.args.cwd);
    const modules = ctx.args._.map((e) => e.trim()).filter(Boolean);
    const projectPkg = await readPackageJSON(cwd).catch(() => ({}));
    if (!projectPkg.dependencies?.nuxt && !projectPkg.devDependencies?.nuxt) {
      logger.warn(`No \`nuxt\` dependency detected in \`${cwd}\`.`);
      const shouldContinue = await logger.prompt(
        `Do you want to continue anyway?`,
        {
          type: "confirm",
          initial: false
        }
      );
      if (shouldContinue !== true) {
        return false;
      }
    }
    const maybeResolvedModules = await Promise.all(modules.map((moduleName) => resolveModule(moduleName, cwd)));
    const r = maybeResolvedModules.filter((x) => x != null);
    logger.info(`Resolved ${r.map((x) => x.pkgName).join(", ")}, adding module(s)...`);
    await addModule(r, { ...ctx.args, cwd }, projectPkg);
    const args = Object.entries(ctx.args).filter(([k]) => k in cwdArgs || k in logLevelArgs).map(([k, v]) => `--${k}=${v}`);
    await runCommand("prepare", args);
  }
});
async function addModule(r, { skipInstall, skipConfig, cwd, dev }, projectPkg) {
  if (!skipInstall) {
    const isDev = Boolean(projectPkg.devDependencies?.nuxt) || dev;
    logger.info(`Installing \`${r.map((x) => x.pkg).join(", ")}\`${isDev ? " development" : ""} dep(s)`);
    const res = await addDependency(r.map((x) => x.pkg), { cwd, dev: isDev, installPeerDependencies: true }).catch(
      (error) => {
        logger.error(error);
        return logger.prompt(
          `Install failed for ${r.map((x) => colors.cyan(x.pkg)).join(", ")}. Do you want to continue adding the module(s) to ${colors.cyan("nuxt.config")}?`,
          {
            type: "confirm",
            initial: false
          }
        );
      }
    );
    if (res === false) {
      return;
    }
  }
  if (!skipConfig) {
    await updateConfig({
      cwd,
      configFile: "nuxt.config",
      async onCreate() {
        logger.info(`Creating \`nuxt.config.ts\``);
        return getDefaultNuxtConfig();
      },
      async onUpdate(config) {
        for (const resolved of r) {
          if (!config.modules) {
            config.modules = [];
          }
          if (config.modules.includes(resolved.pkgName)) {
            logger.info(`\`${resolved.pkgName}\` is already in the \`modules\``);
            return;
          }
          logger.info(`Adding \`${resolved.pkgName}\` to the \`modules\``);
          config.modules.push(resolved.pkgName);
        }
      }
    }).catch((error) => {
      logger.error(`Failed to update \`nuxt.config\`: ${error.message}`);
      logger.error(`Please manually add \`${r.map((x) => x.pkgName).join(", ")}\` to the \`modules\` in \`nuxt.config.ts\``);
      return null;
    });
  }
}
function getDefaultNuxtConfig() {
  return `
// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  modules: []
})`;
}
const packageRegex = /^(@[a-z0-9-~][a-z0-9-._~]*\/)?([a-z0-9-~][a-z0-9-._~]*)(@[^@]+)?$/;
async function resolveModule(moduleName, cwd) {
  let pkgName = moduleName;
  let pkgVersion;
  const reMatch = moduleName.match(packageRegex);
  if (reMatch) {
    if (reMatch[3]) {
      pkgName = `${reMatch[1] || ""}${reMatch[2] || ""}`;
      pkgVersion = reMatch[3].slice(1);
    }
  } else {
    logger.error(`Invalid package name \`${pkgName}\`.`);
    return false;
  }
  const modulesDB = await fetchModules().catch((err) => {
    logger.warn(`Cannot search in the Nuxt Modules database: ${err}`);
    return [];
  });
  const matchedModule = modulesDB.find(
    (module) => module.name === moduleName || module.npm === pkgName || module.aliases?.includes(pkgName)
  );
  if (matchedModule?.npm) {
    pkgName = matchedModule.npm;
  }
  if (matchedModule && matchedModule.compatibility.nuxt) {
    const nuxtVersion = await getNuxtVersion(cwd);
    if (!checkNuxtCompatibility(matchedModule, nuxtVersion)) {
      logger.warn(
        `The module \`${pkgName}\` is not compatible with Nuxt \`${nuxtVersion}\` (requires \`${matchedModule.compatibility.nuxt}\`)`
      );
      const shouldContinue = await logger.prompt(
        "Do you want to continue installing incompatible version?",
        {
          type: "confirm",
          initial: false
        }
      );
      if (shouldContinue !== true) {
        return false;
      }
    }
    const versionMap = matchedModule.compatibility.versionMap;
    if (versionMap) {
      for (const [_nuxtVersion, _moduleVersion] of Object.entries(versionMap)) {
        if (semverExports.satisfies(nuxtVersion, _nuxtVersion)) {
          if (!pkgVersion) {
            pkgVersion = _moduleVersion;
          } else {
            logger.warn(
              `Recommended version of \`${pkgName}\` for Nuxt \`${nuxtVersion}\` is \`${_moduleVersion}\` but you have requested \`${pkgVersion}\``
            );
            pkgVersion = await logger.prompt("Choose a version:", {
              type: "select",
              options: [_moduleVersion, pkgVersion]
            });
          }
          break;
        }
      }
    }
  }
  pkgVersion = pkgVersion || "latest";
  const pkgScope = pkgName.startsWith("@") ? pkgName.split("/")[0] : null;
  const meta = await detectNpmRegistry(pkgScope);
  const headers = {};
  if (meta.authToken) {
    headers.Authorization = `Bearer ${meta.authToken}`;
  }
  const pkgDetails = await $fetch(joinURL(meta.registry, `${pkgName}`), {
    headers
  });
  pkgVersion = pkgDetails["dist-tags"]?.[pkgVersion] || pkgVersion;
  const pkg = pkgDetails.versions[pkgVersion];
  const pkgDependencies = Object.assign(
    pkg.dependencies || {},
    pkg.devDependencies || {}
  );
  if (!pkgDependencies.nuxt && !pkgDependencies["nuxt-edge"] && !pkgDependencies["@nuxt/kit"]) {
    logger.warn(`It seems that \`${pkgName}\` is not a Nuxt module.`);
    const shouldContinue = await logger.prompt(
      `Do you want to continue installing \`${pkgName}\` anyway?`,
      {
        type: "confirm",
        initial: false
      }
    );
    if (shouldContinue !== true) {
      return false;
    }
  }
  return {
    nuxtModule: matchedModule,
    pkg: `${pkgName}@${pkgVersion}`,
    pkgName,
    pkgVersion
  };
}
function getNpmrcPaths() {
  const userNpmrcPath = join$1(homedir(), ".npmrc");
  const cwdNpmrcPath = join$1(process.cwd(), ".npmrc");
  return [cwdNpmrcPath, userNpmrcPath];
}
async function getAuthToken(registry) {
  const paths = getNpmrcPaths();
  const authTokenRegex = new RegExp(`^//${registry.replace(/^https?:\/\//, "").replace(/\/$/, "")}/:_authToken=(.+)$`, "m");
  for (const npmrcPath of paths) {
    let fd;
    try {
      fd = await fs.promises.open(npmrcPath, "r");
      if (await fd.stat().then((r) => r.isFile())) {
        const npmrcContent = await fd.readFile("utf-8");
        const authTokenMatch = npmrcContent.match(authTokenRegex)?.[1];
        if (authTokenMatch) {
          return authTokenMatch.trim();
        }
      }
    } catch {
    } finally {
      await fd?.close();
    }
  }
  return null;
}
async function detectNpmRegistry(scope) {
  const registry = await getRegistry(scope);
  const authToken = await getAuthToken(registry);
  return {
    registry,
    authToken
  };
}
async function getRegistry(scope) {
  if (process.env.COREPACK_NPM_REGISTRY) {
    return process.env.COREPACK_NPM_REGISTRY;
  }
  const registry = await getRegistryFromFile(getNpmrcPaths(), scope);
  if (registry) {
    process.env.COREPACK_NPM_REGISTRY = registry;
  }
  return registry || "https://registry.npmjs.org";
}
async function getRegistryFromFile(paths, scope) {
  for (const npmrcPath of paths) {
    let fd;
    try {
      fd = await fs.promises.open(npmrcPath, "r");
      if (await fd.stat().then((r) => r.isFile())) {
        const npmrcContent = await fd.readFile("utf-8");
        if (scope) {
          const scopedRegex = new RegExp(`^${scope}:registry=(.+)$`, "m");
          const scopedMatch = npmrcContent.match(scopedRegex)?.[1];
          if (scopedMatch) {
            return scopedMatch.trim();
          }
        }
        const defaultRegex = /^\s*registry=(.+)$/m;
        const defaultMatch = npmrcContent.match(defaultRegex)?.[1];
        if (defaultMatch) {
          return defaultMatch.trim();
        }
      }
    } catch {
    } finally {
      await fd?.close();
    }
  }
  return null;
}

export { add as default };
